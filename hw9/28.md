# 28

## Q1

*Q: Examine flag.s. This code “implements” locking with a single memory
flag. Can you understand the assembly?*

A: if flag is 0 and obtained then occupy the lock and set to 1. After the critical section set it back to 0.

## Q2

*Q:When you run with the defaults, does flag.s work? Use the -M and -R
flags to trace variables and registers (and turn on -c to see their values).
Can you predict what value will end up in flag?*

A: 0 (released)

```
PS E:\proj\cs\hw5600\hw9> python3 .\x86.py -p flag.s -M flag,count -R ax,bx -c
ARG seed 0
ARG numthreads 2
ARG program flag.s
ARG interrupt frequency 50
ARG interrupt randomness False
ARG procsched
ARG argv
ARG load address 1000
ARG memsize 128
ARG memtrace flag,count
ARG regtrace ax,bx
ARG cctrace False
ARG printstats False
ARG verbose False


 flag count      ax    bx          Thread 0                Thread 1

    0     0       0     0
    0     0       0     0   1000 mov  flag, %ax
    0     0       0     0   1001 test $0, %ax
    0     0       0     0   1002 jne  .acquire
    1     0       0     0   1003 mov  $1, flag
    1     0       0     0   1004 mov  count, %ax
    1     0       1     0   1005 add  $1, %ax
    1     1       1     0   1006 mov  %ax, count
    0     1       1     0   1007 mov  $0, flag
    0     1       1    -1   1008 sub  $1, %bx
    0     1       1    -1   1009 test $0, %bx
    0     1       1    -1   1010 jgt .top
    0     1       1    -1   1011 halt
    0     1       0     0   ----- Halt;Switch -----  ----- Halt;Switch -----
    0     1       0     0                            1000 mov  flag, %ax
    0     1       0     0                            1001 test $0, %ax
    0     1       0     0                            1002 jne  .acquire
    1     1       0     0                            1003 mov  $1, flag
    1     1       1     0                            1004 mov  count, %ax
    1     1       2     0                            1005 add  $1, %ax
    1     2       2     0                            1006 mov  %ax, count
    0     2       2     0                            1007 mov  $0, flag
    0     2       2    -1                            1008 sub  $1, %bx
    0     2       2    -1                            1009 test $0, %bx
    0     2       2    -1                            1010 jgt .top
    0     2       2    -1                            1011 halt
```

## Q3

*Q:Change the value of the register %bx with the -a flag (e.g., -a bx=2,bx=2
if you are running just two threads). What does the code do? How does it
change your answer for the question above?*

A: 

The loop times will be 2.

```
PS E:\proj\cs\hw5600\hw9> python3 .\x86.py -p flag.s -M flag,count -R ax,bx -a bx=2,bx=2 -c
ARG seed 0
ARG numthreads 2
ARG program flag.s
ARG interrupt frequency 50
ARG interrupt randomness False
ARG procsched
ARG argv bx=2,bx=2
ARG load address 1000
ARG memsize 128
ARG memtrace flag,count
ARG regtrace ax,bx
ARG cctrace False
ARG printstats False
ARG verbose False


 flag count      ax    bx          Thread 0                Thread 1

    0     0       0     2
    0     0       0     2   1000 mov  flag, %ax
    0     0       0     2   1001 test $0, %ax
    0     0       0     2   1002 jne  .acquire
    1     0       0     2   1003 mov  $1, flag
    1     0       0     2   1004 mov  count, %ax
    1     0       1     2   1005 add  $1, %ax
    1     1       1     2   1006 mov  %ax, count
    0     1       1     2   1007 mov  $0, flag
    0     1       1     1   1008 sub  $1, %bx
    0     1       1     1   1009 test $0, %bx
    0     1       1     1   1010 jgt .top
    0     1       0     1   1000 mov  flag, %ax
    0     1       0     1   1001 test $0, %ax
    0     1       0     1   1002 jne  .acquire
    1     1       0     1   1003 mov  $1, flag
    1     1       1     1   1004 mov  count, %ax
    1     1       2     1   1005 add  $1, %ax
    1     2       2     1   1006 mov  %ax, count
    0     2       2     1   1007 mov  $0, flag
    0     2       2     0   1008 sub  $1, %bx
    0     2       2     0   1009 test $0, %bx
    0     2       2     0   1010 jgt .top
    0     2       2     0   1011 halt
    0     2       0     2   ----- Halt;Switch -----  ----- Halt;Switch -----
    0     2       0     2                            1000 mov  flag, %ax
    0     2       0     2                            1001 test $0, %ax
    0     2       0     2                            1002 jne  .acquire
    1     2       0     2                            1003 mov  $1, flag
    1     2       2     2                            1004 mov  count, %ax
    1     2       3     2                            1005 add  $1, %ax
    1     3       3     2                            1006 mov  %ax, count
    0     3       3     2                            1007 mov  $0, flag
    0     3       3     1                            1008 sub  $1, %bx
    0     3       3     1                            1009 test $0, %bx
    0     3       3     1                            1010 jgt .top
    0     3       0     1                            1000 mov  flag, %ax
    0     3       0     1                            1001 test $0, %ax
    0     3       0     1                            1002 jne  .acquire
    1     3       0     1                            1003 mov  $1, flag
    1     3       3     1                            1004 mov  count, %ax
    1     3       4     1                            1005 add  $1, %ax
    1     4       4     1                            1006 mov  %ax, count
    0     4       4     1                            1007 mov  $0, flag
    0     4       4     0                            1008 sub  $1, %bx
    0     4       4     0                            1009 test $0, %bx
    0     4       4     0                            1010 jgt .top
    0     4       4     0                            1011 halt
```

## Q4

*Q: Set bx to a high value for each thread, and then use the -i flag to generate
different interrupt frequencies; what values lead to a bad outcomes? Which
lead to good outcomes?*

A:

```
PS E:\proj\cs\hw5600\hw9> python3 .\x86.py -p flag.s -M flag,count -R ax,bx -a bx=6,bx=6 -i 5 -c
ARG seed 0
ARG numthreads 2
ARG program flag.s
ARG interrupt frequency 5
ARG interrupt randomness False
ARG procsched
ARG argv bx=6,bx=6
ARG load address 1000
ARG memsize 128
ARG memtrace flag,count
ARG regtrace ax,bx
ARG cctrace False
ARG printstats False
ARG verbose False


 flag count      ax    bx          Thread 0                Thread 1

    0     0       0     6
    0     0       0     6   1000 mov  flag, %ax
    0     0       0     6   1001 test $0, %ax
    0     0       0     6   1002 jne  .acquire
    1     0       0     6   1003 mov  $1, flag
    1     0       0     6   1004 mov  count, %ax
    1     0       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     0       1     6                            1000 mov  flag, %ax
    1     0       1     6                            1001 test $0, %ax
    1     0       1     6                            1002 jne  .acquire
    1     0       1     6                            1000 mov  flag, %ax
    1     0       1     6                            1001 test $0, %ax
    1     0       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     0       1     6   1005 add  $1, %ax
    1     1       1     6   1006 mov  %ax, count
    0     1       1     6   1007 mov  $0, flag
    0     1       1     5   1008 sub  $1, %bx
    0     1       1     5   1009 test $0, %bx
    0     1       1     6   ------ Interrupt ------  ------ Interrupt ------
    0     1       1     6                            1002 jne  .acquire
    0     1       0     6                            1000 mov  flag, %ax
    0     1       0     6                            1001 test $0, %ax
    0     1       0     6                            1002 jne  .acquire
    1     1       0     6                            1003 mov  $1, flag
    1     1       1     5   ------ Interrupt ------  ------ Interrupt ------
    1     1       1     5   1010 jgt .top
    1     1       1     5   1000 mov  flag, %ax
    1     1       1     5   1001 test $0, %ax
    1     1       1     5   1002 jne  .acquire
    1     1       1     5   1000 mov  flag, %ax
    1     1       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     1       1     6                            1004 mov  count, %ax
    1     1       2     6                            1005 add  $1, %ax
    1     2       2     6                            1006 mov  %ax, count
    0     2       2     6                            1007 mov  $0, flag
    0     2       2     5                            1008 sub  $1, %bx
    0     2       1     5   ------ Interrupt ------  ------ Interrupt ------
    0     2       1     5   1001 test $0, %ax
    0     2       1     5   1002 jne  .acquire
    0     2       0     5   1000 mov  flag, %ax
    0     2       0     5   1001 test $0, %ax
    0     2       0     5   1002 jne  .acquire
    0     2       2     5   ------ Interrupt ------  ------ Interrupt ------
    0     2       2     5                            1009 test $0, %bx
    0     2       2     5                            1010 jgt .top
    0     2       0     5                            1000 mov  flag, %ax
    0     2       0     5                            1001 test $0, %ax
    0     2       0     5                            1002 jne  .acquire
    0     2       0     5   ------ Interrupt ------  ------ Interrupt ------
    1     2       0     5   1003 mov  $1, flag
    1     2       2     5   1004 mov  count, %ax
    1     2       3     5   1005 add  $1, %ax
    1     3       3     5   1006 mov  %ax, count
    0     3       3     5   1007 mov  $0, flag
    0     3       0     5   ------ Interrupt ------  ------ Interrupt ------
    1     3       0     5                            1003 mov  $1, flag
    1     3       3     5                            1004 mov  count, %ax
    1     3       4     5                            1005 add  $1, %ax
    1     4       4     5                            1006 mov  %ax, count
    0     4       4     5                            1007 mov  $0, flag
    0     4       3     5   ------ Interrupt ------  ------ Interrupt ------
    0     4       3     4   1008 sub  $1, %bx
    0     4       3     4   1009 test $0, %bx
    0     4       3     4   1010 jgt .top
    0     4       0     4   1000 mov  flag, %ax
    0     4       0     4   1001 test $0, %ax
    0     4       4     5   ------ Interrupt ------  ------ Interrupt ------
    0     4       4     4                            1008 sub  $1, %bx
    0     4       4     4                            1009 test $0, %bx
    0     4       4     4                            1010 jgt .top
    0     4       0     4                            1000 mov  flag, %ax
    0     4       0     4                            1001 test $0, %ax
    0     4       0     4   ------ Interrupt ------  ------ Interrupt ------
    0     4       0     4   1002 jne  .acquire
    1     4       0     4   1003 mov  $1, flag
    1     4       4     4   1004 mov  count, %ax
    1     4       5     4   1005 add  $1, %ax
    1     5       5     4   1006 mov  %ax, count
    1     5       0     4   ------ Interrupt ------  ------ Interrupt ------
    1     5       0     4                            1002 jne  .acquire
    1     5       0     4                            1003 mov  $1, flag
    1     5       5     4                            1004 mov  count, %ax
    1     5       6     4                            1005 add  $1, %ax
    1     6       6     4                            1006 mov  %ax, count
    1     6       5     4   ------ Interrupt ------  ------ Interrupt ------
    0     6       5     4   1007 mov  $0, flag
    0     6       5     3   1008 sub  $1, %bx
    0     6       5     3   1009 test $0, %bx
    0     6       5     3   1010 jgt .top
    0     6       0     3   1000 mov  flag, %ax
    0     6       6     4   ------ Interrupt ------  ------ Interrupt ------
    0     6       6     4                            1007 mov  $0, flag
    0     6       6     3                            1008 sub  $1, %bx
    0     6       6     3                            1009 test $0, %bx
    0     6       6     3                            1010 jgt .top
    0     6       0     3                            1000 mov  flag, %ax
    0     6       0     3   ------ Interrupt ------  ------ Interrupt ------
    0     6       0     3   1001 test $0, %ax
    0     6       0     3   1002 jne  .acquire
    1     6       0     3   1003 mov  $1, flag
    1     6       6     3   1004 mov  count, %ax
    1     6       7     3   1005 add  $1, %ax
    1     6       0     3   ------ Interrupt ------  ------ Interrupt ------
    1     6       0     3                            1001 test $0, %ax
    1     6       0     3                            1002 jne  .acquire
    1     6       0     3                            1003 mov  $1, flag
    1     6       6     3                            1004 mov  count, %ax
    1     6       7     3                            1005 add  $1, %ax
    1     6       7     3   ------ Interrupt ------  ------ Interrupt ------
    1     7       7     3   1006 mov  %ax, count
    0     7       7     3   1007 mov  $0, flag
    0     7       7     2   1008 sub  $1, %bx
    0     7       7     2   1009 test $0, %bx
    0     7       7     2   1010 jgt .top
    0     7       7     3   ------ Interrupt ------  ------ Interrupt ------
    0     7       7     3                            1006 mov  %ax, count
    0     7       7     3                            1007 mov  $0, flag
    0     7       7     2                            1008 sub  $1, %bx
    0     7       7     2                            1009 test $0, %bx
    0     7       7     2                            1010 jgt .top
    0     7       7     2   ------ Interrupt ------  ------ Interrupt ------
    0     7       0     2   1000 mov  flag, %ax
    0     7       0     2   1001 test $0, %ax
    0     7       0     2   1002 jne  .acquire
    1     7       0     2   1003 mov  $1, flag
    1     7       7     2   1004 mov  count, %ax
    1     7       7     2   ------ Interrupt ------  ------ Interrupt ------
    1     7       1     2                            1000 mov  flag, %ax
    1     7       1     2                            1001 test $0, %ax
    1     7       1     2                            1002 jne  .acquire
    1     7       1     2                            1000 mov  flag, %ax
    1     7       1     2                            1001 test $0, %ax
    1     7       7     2   ------ Interrupt ------  ------ Interrupt ------
    1     7       8     2   1005 add  $1, %ax
    1     8       8     2   1006 mov  %ax, count
    0     8       8     2   1007 mov  $0, flag
    0     8       8     1   1008 sub  $1, %bx
    0     8       8     1   1009 test $0, %bx
    0     8       1     2   ------ Interrupt ------  ------ Interrupt ------
    0     8       1     2                            1002 jne  .acquire
    0     8       0     2                            1000 mov  flag, %ax
    0     8       0     2                            1001 test $0, %ax
    0     8       0     2                            1002 jne  .acquire
    1     8       0     2                            1003 mov  $1, flag
    1     8       8     1   ------ Interrupt ------  ------ Interrupt ------
    1     8       8     1   1010 jgt .top
    1     8       1     1   1000 mov  flag, %ax
    1     8       1     1   1001 test $0, %ax
    1     8       1     1   1002 jne  .acquire
    1     8       1     1   1000 mov  flag, %ax
    1     8       0     2   ------ Interrupt ------  ------ Interrupt ------
    1     8       8     2                            1004 mov  count, %ax
    1     8       9     2                            1005 add  $1, %ax
    1     9       9     2                            1006 mov  %ax, count
    0     9       9     2                            1007 mov  $0, flag
    0     9       9     1                            1008 sub  $1, %bx
    0     9       1     1   ------ Interrupt ------  ------ Interrupt ------
    0     9       1     1   1001 test $0, %ax
    0     9       1     1   1002 jne  .acquire
    0     9       0     1   1000 mov  flag, %ax
    0     9       0     1   1001 test $0, %ax
    0     9       0     1   1002 jne  .acquire
    0     9       9     1   ------ Interrupt ------  ------ Interrupt ------
    0     9       9     1                            1009 test $0, %bx
    0     9       9     1                            1010 jgt .top
    0     9       0     1                            1000 mov  flag, %ax
    0     9       0     1                            1001 test $0, %ax
    0     9       0     1                            1002 jne  .acquire
    0     9       0     1   ------ Interrupt ------  ------ Interrupt ------
    1     9       0     1   1003 mov  $1, flag
    1     9       9     1   1004 mov  count, %ax
    1     9      10     1   1005 add  $1, %ax
    1    10      10     1   1006 mov  %ax, count
    0    10      10     1   1007 mov  $0, flag
    0    10       0     1   ------ Interrupt ------  ------ Interrupt ------
    1    10       0     1                            1003 mov  $1, flag
    1    10      10     1                            1004 mov  count, %ax
    1    10      11     1                            1005 add  $1, %ax
    1    11      11     1                            1006 mov  %ax, count
    0    11      11     1                            1007 mov  $0, flag
    0    11      10     1   ------ Interrupt ------  ------ Interrupt ------
    0    11      10     0   1008 sub  $1, %bx
    0    11      10     0   1009 test $0, %bx
    0    11      10     0   1010 jgt .top
    0    11      10     0   1011 halt
    0    11      11     1   ----- Halt;Switch -----  ----- Halt;Switch -----
    0    11      11     0                            1008 sub  $1, %bx
    0    11      11     0   ------ Interrupt ------  ------ Interrupt ------
    0    11      11     0                            1009 test $0, %bx
    0    11      11     0                            1010 jgt .top
    0    11      11     0                            1011 halt
```

```
5 11
6 11
7 9
8 10
9 11
10 12
11 12
12 11
13 10
14 10
15 12
16 12
```

## Q5

*Q:Now let’s look at the program test-and-set.s. First, try to understand
the code, which uses the xchg instruction to build a simple locking primitive. How is the lock acquire written? How about lock release?*

A:

Acquire: see if mutex is 0
Release: set mutex to 0

## Q6

*Q. Now run the code, changing the value of the interrupt interval (-i) again,
and making sure to loop for a number of times. Does the code always work
as expected? Does it sometimes lead to an inefficient use of the CPU? How
could you quantify that?*

A: Yes it's always correct. But many times it repeat over .acquire
We can track the loops when attempting to gain the lock.

```
PS E:\proj\cs\hw5600\hw9> python3 .\x86.py -p test-and-set.s -M mutex,count -R ax,bx -a bx=6,bx=6 -c -i 6
ARG seed 0
ARG numthreads 2
ARG program test-and-set.s
ARG interrupt frequency 6
ARG interrupt randomness False
ARG procsched
ARG argv bx=6,bx=6
ARG load address 1000
ARG memsize 128
ARG memtrace mutex,count
ARG regtrace ax,bx
ARG cctrace False
ARG printstats False
ARG verbose False


mutex count      ax    bx          Thread 0                Thread 1

    0     0       0     6
    0     0       1     6   1000 mov  $1, %ax
    1     0       0     6   1001 xchg %ax, mutex
    1     0       0     6   1002 test $0, %ax
    1     0       0     6   1003 jne  .acquire
    1     0       0     6   1004 mov  count, %ax
    1     0       1     6   1005 add  $1, %ax
    1     0       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     0       1     6                            1000 mov  $1, %ax
    1     0       1     6                            1001 xchg %ax, mutex
    1     0       1     6                            1002 test $0, %ax
    1     0       1     6                            1003 jne  .acquire
    1     0       1     6                            1000 mov  $1, %ax
    1     0       1     6                            1001 xchg %ax, mutex
    1     0       1     6   ------ Interrupt ------  ------ Interrupt ------
    1     1       1     6   1006 mov  %ax, count
    0     1       1     6   1007 mov  $0, mutex
    0     1       1     5   1008 sub  $1, %bx
    0     1       1     5   1009 test $0, %bx
    0     1       1     5   1010 jgt .top
    0     1       1     5   1000 mov  $1, %ax
    0     1       1     6   ------ Interrupt ------  ------ Interrupt ------
    0     1       1     6                            1002 test $0, %ax
    0     1       1     6                            1003 jne  .acquire
    0     1       1     6                            1000 mov  $1, %ax
    1     1       0     6                            1001 xchg %ax, mutex
    1     1       0     6                            1002 test $0, %ax
    1     1       0     6                            1003 jne  .acquire
    1     1       1     5   ------ Interrupt ------  ------ Interrupt ------
    1     1       1     5   1001 xchg %ax, mutex
    1     1       1     5   1002 test $0, %ax
    1     1       1     5   1003 jne  .acquire
    1     1       1     5   1000 mov  $1, %ax
    1     1       1     5   1001 xchg %ax, mutex
    1     1       1     5   1002 test $0, %ax
    1     1       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     1       1     6                            1004 mov  count, %ax
    1     1       2     6                            1005 add  $1, %ax
    1     2       2     6                            1006 mov  %ax, count
    0     2       2     6                            1007 mov  $0, mutex
    0     2       2     5                            1008 sub  $1, %bx
    0     2       2     5                            1009 test $0, %bx
    0     2       1     5   ------ Interrupt ------  ------ Interrupt ------
    0     2       1     5   1003 jne  .acquire
    0     2       1     5   1000 mov  $1, %ax
    1     2       0     5   1001 xchg %ax, mutex
    1     2       0     5   1002 test $0, %ax
    1     2       0     5   1003 jne  .acquire
    1     2       2     5   1004 mov  count, %ax
    1     2       2     5   ------ Interrupt ------  ------ Interrupt ------
    1     2       2     5                            1010 jgt .top
    1     2       1     5                            1000 mov  $1, %ax
    1     2       1     5                            1001 xchg %ax, mutex
    1     2       1     5                            1002 test $0, %ax
    1     2       1     5                            1003 jne  .acquire
    1     2       1     5                            1000 mov  $1, %ax
    1     2       2     5   ------ Interrupt ------  ------ Interrupt ------
    1     2       3     5   1005 add  $1, %ax
    1     3       3     5   1006 mov  %ax, count
    0     3       3     5   1007 mov  $0, mutex
    0     3       3     4   1008 sub  $1, %bx
    0     3       3     4   1009 test $0, %bx
    0     3       3     4   1010 jgt .top
    0     3       1     5   ------ Interrupt ------  ------ Interrupt ------
    1     3       0     5                            1001 xchg %ax, mutex
    1     3       0     5                            1002 test $0, %ax
    1     3       0     5                            1003 jne  .acquire
    1     3       3     5                            1004 mov  count, %ax
    1     3       4     5                            1005 add  $1, %ax
    1     4       4     5                            1006 mov  %ax, count
    1     4       3     4   ------ Interrupt ------  ------ Interrupt ------
    1     4       1     4   1000 mov  $1, %ax
    1     4       1     4   1001 xchg %ax, mutex
    1     4       1     4   1002 test $0, %ax
    1     4       1     4   1003 jne  .acquire
    1     4       1     4   1000 mov  $1, %ax
    1     4       1     4   1001 xchg %ax, mutex
    1     4       4     5   ------ Interrupt ------  ------ Interrupt ------
    0     4       4     5                            1007 mov  $0, mutex
    0     4       4     4                            1008 sub  $1, %bx
    0     4       4     4                            1009 test $0, %bx
    0     4       4     4                            1010 jgt .top
    0     4       1     4                            1000 mov  $1, %ax
    1     4       0     4                            1001 xchg %ax, mutex
    1     4       1     4   ------ Interrupt ------  ------ Interrupt ------
    1     4       1     4   1002 test $0, %ax
    1     4       1     4   1003 jne  .acquire
    1     4       1     4   1000 mov  $1, %ax
    1     4       1     4   1001 xchg %ax, mutex
    1     4       1     4   1002 test $0, %ax
    1     4       1     4   1003 jne  .acquire
    1     4       0     4   ------ Interrupt ------  ------ Interrupt ------
    1     4       0     4                            1002 test $0, %ax
    1     4       0     4                            1003 jne  .acquire
    1     4       4     4                            1004 mov  count, %ax
    1     4       5     4                            1005 add  $1, %ax
    1     5       5     4                            1006 mov  %ax, count
    0     5       5     4                            1007 mov  $0, mutex
    0     5       1     4   ------ Interrupt ------  ------ Interrupt ------
    0     5       1     4   1000 mov  $1, %ax
    1     5       0     4   1001 xchg %ax, mutex
    1     5       0     4   1002 test $0, %ax
    1     5       0     4   1003 jne  .acquire
    1     5       5     4   1004 mov  count, %ax
    1     5       6     4   1005 add  $1, %ax
    1     5       5     4   ------ Interrupt ------  ------ Interrupt ------
    1     5       5     3                            1008 sub  $1, %bx
    1     5       5     3                            1009 test $0, %bx
    1     5       5     3                            1010 jgt .top
    1     5       1     3                            1000 mov  $1, %ax
    1     5       1     3                            1001 xchg %ax, mutex
    1     5       1     3                            1002 test $0, %ax
    1     5       6     4   ------ Interrupt ------  ------ Interrupt ------
    1     6       6     4   1006 mov  %ax, count
    0     6       6     4   1007 mov  $0, mutex
    0     6       6     3   1008 sub  $1, %bx
    0     6       6     3   1009 test $0, %bx
    0     6       6     3   1010 jgt .top
    0     6       1     3   1000 mov  $1, %ax
    0     6       1     3   ------ Interrupt ------  ------ Interrupt ------
    0     6       1     3                            1003 jne  .acquire
    0     6       1     3                            1000 mov  $1, %ax
    1     6       0     3                            1001 xchg %ax, mutex
    1     6       0     3                            1002 test $0, %ax
    1     6       0     3                            1003 jne  .acquire
    1     6       6     3                            1004 mov  count, %ax
    1     6       1     3   ------ Interrupt ------  ------ Interrupt ------
    1     6       1     3   1001 xchg %ax, mutex
    1     6       1     3   1002 test $0, %ax
    1     6       1     3   1003 jne  .acquire
    1     6       1     3   1000 mov  $1, %ax
    1     6       1     3   1001 xchg %ax, mutex
    1     6       1     3   1002 test $0, %ax
    1     6       6     3   ------ Interrupt ------  ------ Interrupt ------
    1     6       7     3                            1005 add  $1, %ax
    1     7       7     3                            1006 mov  %ax, count
    0     7       7     3                            1007 mov  $0, mutex
    0     7       7     2                            1008 sub  $1, %bx
    0     7       7     2                            1009 test $0, %bx
    0     7       7     2                            1010 jgt .top
    0     7       1     3   ------ Interrupt ------  ------ Interrupt ------
    0     7       1     3   1003 jne  .acquire
    0     7       1     3   1000 mov  $1, %ax
    1     7       0     3   1001 xchg %ax, mutex
    1     7       0     3   1002 test $0, %ax
    1     7       0     3   1003 jne  .acquire
    1     7       7     3   1004 mov  count, %ax
    1     7       7     2   ------ Interrupt ------  ------ Interrupt ------
    1     7       1     2                            1000 mov  $1, %ax
    1     7       1     2                            1001 xchg %ax, mutex
    1     7       1     2                            1002 test $0, %ax
    1     7       1     2                            1003 jne  .acquire
    1     7       1     2                            1000 mov  $1, %ax
    1     7       1     2                            1001 xchg %ax, mutex
    1     7       7     3   ------ Interrupt ------  ------ Interrupt ------
    1     7       8     3   1005 add  $1, %ax
    1     8       8     3   1006 mov  %ax, count
    0     8       8     3   1007 mov  $0, mutex
    0     8       8     2   1008 sub  $1, %bx
    0     8       8     2   1009 test $0, %bx
    0     8       8     2   1010 jgt .top
    0     8       1     2   ------ Interrupt ------  ------ Interrupt ------
    0     8       1     2                            1002 test $0, %ax
    0     8       1     2                            1003 jne  .acquire
    0     8       1     2                            1000 mov  $1, %ax
    1     8       0     2                            1001 xchg %ax, mutex
    1     8       0     2                            1002 test $0, %ax
    1     8       0     2                            1003 jne  .acquire
    1     8       8     2   ------ Interrupt ------  ------ Interrupt ------
    1     8       1     2   1000 mov  $1, %ax
    1     8       1     2   1001 xchg %ax, mutex
    1     8       1     2   1002 test $0, %ax
    1     8       1     2   1003 jne  .acquire
    1     8       1     2   1000 mov  $1, %ax
    1     8       1     2   1001 xchg %ax, mutex
    1     8       0     2   ------ Interrupt ------  ------ Interrupt ------
    1     8       8     2                            1004 mov  count, %ax
    1     8       9     2                            1005 add  $1, %ax
    1     9       9     2                            1006 mov  %ax, count
    0     9       9     2                            1007 mov  $0, mutex
    0     9       9     1                            1008 sub  $1, %bx
    0     9       9     1                            1009 test $0, %bx
    0     9       1     2   ------ Interrupt ------  ------ Interrupt ------
    0     9       1     2   1002 test $0, %ax
    0     9       1     2   1003 jne  .acquire
    0     9       1     2   1000 mov  $1, %ax
    1     9       0     2   1001 xchg %ax, mutex
    1     9       0     2   1002 test $0, %ax
    1     9       0     2   1003 jne  .acquire
    1     9       9     1   ------ Interrupt ------  ------ Interrupt ------
    1     9       9     1                            1010 jgt .top
    1     9       1     1                            1000 mov  $1, %ax
    1     9       1     1                            1001 xchg %ax, mutex
    1     9       1     1                            1002 test $0, %ax
    1     9       1     1                            1003 jne  .acquire
    1     9       1     1                            1000 mov  $1, %ax
    1     9       0     2   ------ Interrupt ------  ------ Interrupt ------
    1     9       9     2   1004 mov  count, %ax
    1     9      10     2   1005 add  $1, %ax
    1    10      10     2   1006 mov  %ax, count
    0    10      10     2   1007 mov  $0, mutex
    0    10      10     1   1008 sub  $1, %bx
    0    10      10     1   1009 test $0, %bx
    0    10       1     1   ------ Interrupt ------  ------ Interrupt ------
    1    10       0     1                            1001 xchg %ax, mutex
    1    10       0     1                            1002 test $0, %ax
    1    10       0     1                            1003 jne  .acquire
    1    10      10     1                            1004 mov  count, %ax
    1    10      11     1                            1005 add  $1, %ax
    1    11      11     1                            1006 mov  %ax, count
    1    11      10     1   ------ Interrupt ------  ------ Interrupt ------
    1    11      10     1   1010 jgt .top
    1    11       1     1   1000 mov  $1, %ax
    1    11       1     1   1001 xchg %ax, mutex
    1    11       1     1   1002 test $0, %ax
    1    11       1     1   1003 jne  .acquire
    1    11       1     1   1000 mov  $1, %ax
    1    11      11     1   ------ Interrupt ------  ------ Interrupt ------
    0    11      11     1                            1007 mov  $0, mutex
    0    11      11     0                            1008 sub  $1, %bx
    0    11      11     0                            1009 test $0, %bx
    0    11      11     0                            1010 jgt .top
    0    11      11     0                            1011 halt
    0    11       1     1   ----- Halt;Switch -----  ----- Halt;Switch -----
    1    11       0     1   1001 xchg %ax, mutex
    1    11       0     1   ------ Interrupt ------  ------ Interrupt ------
    1    11       0     1   1002 test $0, %ax
    1    11       0     1   1003 jne  .acquire
    1    11      11     1   1004 mov  count, %ax
    1    11      12     1   1005 add  $1, %ax
    1    12      12     1   1006 mov  %ax, count
    0    12      12     1   1007 mov  $0, mutex
    0    12      12     1   ------ Interrupt ------  ------ Interrupt ------
    0    12      12     0   1008 sub  $1, %bx
    0    12      12     0   1009 test $0, %bx
    0    12      12     0   1010 jgt .top
    0    12      12     0   1011 halt
```

## Q7

*Q:Use the -P flag to generate specific tests of the locking code. For example,
run a schedule that grabs the lock in the first thread, but then tries to acquire
it in the second. Does the right thing happen? What else should you test?*

A: It acts correctly.

```
PS E:\proj\cs\hw5600\hw9> python3 .\x86.py -p test-and-set.s -M mutex,count -R ax,bx -a bx=6,bx=6 -c -P 1111000000000000

ARG seed 0
ARG numthreads 2
ARG program test-and-set.s
ARG interrupt frequency 50
ARG interrupt randomness False
ARG procsched 1111000000000000
ARG argv bx=6,bx=6
ARG load address 1000
ARG memsize 128
ARG memtrace mutex,count
ARG regtrace ax,bx
ARG cctrace False
ARG printstats False
ARG verbose False


mutex count      ax    bx          Thread 0                Thread 1

    0     0       0     6
    0     0       1     6                            1000 mov  $1, %ax
    1     0       0     6                            1001 xchg %ax, mutex
    1     0       0     6                            1002 test $0, %ax
    1     0       0     6                            1003 jne  .acquire
    1     0       0     6   ------ Interrupt ------  ------ Interrupt ------
    1     0       1     6   1000 mov  $1, %ax
    1     0       1     6   1001 xchg %ax, mutex
    1     0       1     6   1002 test $0, %ax
    1     0       1     6   1003 jne  .acquire
    1     0       1     6   1000 mov  $1, %ax
    1     0       1     6   1001 xchg %ax, mutex
    1     0       1     6   1002 test $0, %ax
    1     0       1     6   1003 jne  .acquire
    1     0       1     6   1000 mov  $1, %ax
    1     0       1     6   1001 xchg %ax, mutex
    1     0       1     6   1002 test $0, %ax
    1     0       1     6   1003 jne  .acquire
```

## Q8

*Q:Now let’s look at the code in peterson.s, which implements Peterson’s
algorithm (mentioned in a sidebar in the text). Study the code and see if
you can make sense of it*

A: An array storing the locks, and if one thread needs the lock, then spin if the turn is not itself or the lock was not released yet, then set the lock and enter the critical section.

## Q9

*Q: Now run the code with different values of -i. What kinds of different behavior do you see? Make sure to set the thread IDs appropriately (using -a
bx=0,bx=1 for example) as the code assumes it.*

A: Interval doesn't effect the outcome.

```
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p peterson.s -a bx=0,bx=1 -M turn,count,flag -R ax,bx,cx -c -i 2


 turn count  flag      ax    bx    cx          Thread 0                Thread 1

    0     0     0       0     0     0
    0     0     0       0     0     0   1000 lea flag, %fx
    0     0     0       0     0     0   1001 mov %bx, %cx
    0     0     0       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     0       0     1     0                            1000 lea flag, %fx
    0     0     0       0     1     1                            1001 mov %bx, %cx
    0     0     0       0     0     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     0       0     0     0   1002 neg %cx
    0     0     0       0     0     1   1003 add $1, %cx
    0     0     0       0     1     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     0       0     1    -1                            1002 neg %cx
    0     0     0       0     1     0                            1003 add $1, %cx
    0     0     0       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       0     0     1   1004 mov $1, 0(%fx,%bx,4)
    1     0     1       0     0     1   1005 mov %cx, turn
    1     0     1       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     0     1       0     1     0                            1004 mov $1, 0(%fx,%bx,4)
    0     0     1       0     1     0                            1005 mov %cx, turn
    0     0     1       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     0     1   1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     0     1   1007 test $1, %ax
    0     0     1       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       1     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     0     1   1008 jne .fini
    0     0     1       0     0     1   1009 mov turn, %ax
    0     0     1       1     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     1     0                            1008 jne .fini
    0     0     1       0     1     0                            1009 mov turn, %ax
    0     0     1       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       0     0     1   1010 test %cx, %ax
    0     0     1       0     0     1   1011 je .spin1
    0     0     1       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       0     1     0                            1010 test %cx, %ax
    0     0     1       0     1     0                            1011 je .spin1
    0     0     1       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       0     0     1   1012 mov count, %ax
    0     0     1       1     0     1   1013 add $1, %ax
    0     0     1       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       1     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     1     1       1     0     1   1014 mov %ax, count
    0     1     0       1     0     1   1015 mov $0, 0(%fx,%bx,4)
    0     1     0       1     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     1     0       1     1     0                            1008 jne .fini
    0     1     0       0     1     0                            1009 mov turn, %ax
    0     1     0       1     0     1   ------ Interrupt ------  ------ Interrupt ------
    1     1     0       1     0     1   1016 mov %cx, turn
    1     1     0       1     0     1   1017 halt
    1     1     0       0     1     0   ----- Halt;Switch -----  ----- Halt;Switch -----
    1     1     0       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     1     0       0     1     0                            1010 test %cx, %ax
    1     1     0       0     1     0                            1011 je .spin1
    1     1     0       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     1     0       0     1     0                            1006 mov 0(%fx,%cx,4), %ax
    1     1     0       0     1     0                            1007 test $1, %ax
    1     1     0       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     1     0       0     1     0                            1008 jne .fini
    1     1     0       1     1     0                            1012 mov count, %ax
    1     1     0       1     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     1     0       2     1     0                            1013 add $1, %ax
    1     2     0       2     1     0                            1014 mov %ax, count
    1     2     0       2     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     2     0       2     1     0                            1015 mov $0, 0(%fx,%bx,4)
    0     2     0       2     1     0                            1016 mov %cx, turn
    0     2     0       2     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     2     0       2     1     0                            1017 halt
```

## Q10

*Q:Can you control the scheduling (with the -P flag) to “prove” that the code
works? What are the different cases you should show hold? Think about
mutual exclusion and deadlock avoidance*

A:

```
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p peterson.s -a bx=0,bx=1 -M turn,count,flag -R ax,bx,cx -c -P 0000001111111111111



 turn count  flag      ax    bx    cx          Thread 0                Thread 1

    0     0     0       0     0     0
    0     0     0       0     0     0   1000 lea flag, %fx
    0     0     0       0     0     0   1001 mov %bx, %cx
    0     0     0       0     0     0   1002 neg %cx
    0     0     0       0     0     1   1003 add $1, %cx
    0     0     1       0     0     1   1004 mov $1, 0(%fx,%bx,4)
    1     0     1       0     0     1   1005 mov %cx, turn
    1     0     1       0     1     0   ------ Interrupt ------  ------ Interrupt ------
    1     0     1       0     1     0                            1000 lea flag, %fx
    1     0     1       0     1     1                            1001 mov %bx, %cx
    1     0     1       0     1    -1                            1002 neg %cx
    1     0     1       0     1     0                            1003 add $1, %cx
    1     0     1       0     1     0                            1004 mov $1, 0(%fx,%bx,4)
    0     0     1       0     1     0                            1005 mov %cx, turn
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       1     1     0                            1008 jne .fini
    0     0     1       0     1     0                            1009 mov turn, %ax
    0     0     1       0     1     0                            1010 test %cx, %ax
    0     0     1       0     1     0                            1011 je .spin1
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     0     1   1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     0     1   1007 test $1, %ax
    0     0     1       1     0     1   1008 jne .fini
    0     0     1       0     0     1   1009 mov turn, %ax
    0     0     1       0     0     1   1010 test %cx, %ax
    0     0     1       0     0     1   1011 je .spin1
    0     0     1       1     1     0   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       1     1     0                            1008 jne .fini
    0     0     1       0     1     0                            1009 mov turn, %ax
    0     0     1       0     1     0                            1010 test %cx, %ax
    0     0     1       0     1     0                            1011 je .spin1
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       1     1     0                            1008 jne .fini
    0     0     1       0     1     0                            1009 mov turn, %ax
    0     0     1       0     1     0                            1010 test %cx, %ax
    0     0     1       0     1     0                            1011 je .spin1
    0     0     1       1     1     0                            1006 mov 0(%fx,%cx,4), %ax
    0     0     1       1     1     0                            1007 test $1, %ax
    0     0     1       0     0     1   ------ Interrupt ------  ------ Interrupt ------
    0     0     1       0     0     1   1012 mov count, %ax
    0     0     1       1     0     1   1013 add $1, %ax
    0     1     1       1     0     1   1014 mov %ax, count
    0     1     0       1     0     1   1015 mov $0, 0(%fx,%bx,4)
    1     1     0       1     0     1   1016 mov %cx, turn
    1     1     0       1     0     1   1017 halt
    1     1     0       1     1     0   ----- Halt;Switch -----  ----- Halt;Switch -----
    1     1     0       1     1     0                            1008 jne .fini
    1     1     0       1     1     0                            1009 mov turn, %ax
    1     1     0       1     1     0                            1010 test %cx, %ax
    1     1     0       1     1     0                            1011 je .spin1
    1     1     0       1     1     0                            1012 mov count, %ax
    1     1     0       2     1     0                            1013 add $1, %ax
    1     2     0       2     1     0                            1014 mov %ax, count
    1     2     0       2     1     0                            1015 mov $0, 0(%fx,%bx,4)
    0     2     0       2     1     0                            1016 mov %cx, turn
    0     2     0       2     1     0                            1017 halt
```

## Q11

*Q:Now study the code for the ticket lock in ticket.s. Does it match the code
in the chapter? Then run with the following flags: -a bx=1000,bx=1000
(causing each thread to loop through the critical section 1000 times). Watch
what happens; do the threads spend much time spin-waiting for the lock?*

A: Yes it did.

```
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p ticket.s -a bx=100,bx=100 -M count,turn,ticket -R ax,bx,cx -c -i 4
```

## Q12

*Q:How does the code behave as you add more threads?*

A: 

'tryagain' became more frequent.

```
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p ticket.s -t 3 -a bx=3,bx=3,bx=3 -M count,turn,ticket -R ax,bx,cx -c -i 5
```

## Q13

*Q:Now examine yield.s, in which a yield instruction enables one thread
to yield control of the CPU (realistically, this would be an OS primitive, but
for the simplicity, we assume an instruction does the task). Find a scenario
where test-and-set.s wastes cycles spinning, but yield.s does not.
How many instructions are saved? In what scenarios do these savings arise?*

A:

```
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p yield.s -a bx=4,bx=4 -M count,mutex -R ax,bx -c -i 6
PS E:\proj\cs\hw5600\hw9> python .\x86.py -p test-and-set.s -a bx=4,bx=4 -M count,mutex -R ax,bx -c -i 6
```

One instruction was saved in each cycle. 'jne & mov' -> 'yield'.

When the mutex lock was not occupied, it was more frequent.

## Q14

*Q:Finally, examine test-and-test-and-set.s. What does this lock do?
What kind of savings does it introduce as compared to test-and-set.s?*

A: It serves the same aim, but it can save time and resources because we don't do `xchg` a lot so the mem write is less.



